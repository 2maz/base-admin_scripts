#! /usr/bin/env ruby
require 'find'
require 'optparse'
require 'autoproj'
require 'autobuild'
require 'rock/packaging'
require 'tempfile'
require 'yaml'

def build_locally(packager, pkg_name, options)
    options, unknown_options = Kernel.filter_options options,
        :release_name => 'local',
        :rock_base_install_dir => '/opt/rock',
        :patch_dir => nil,
        :result_dir => nil,
        :package_version => nil,
        :debian_package_name => pkg_name.gsub("/",'-'),
        :meta_depends => nil,
        :rebuild => false,
        :install => false

    arguments = ""
    if options[:release_name]
        arguments += "--release-name #{options[:release_name]}"
        arguments += " "
    end
    if options[:rock_base_install_dir]
        arguments += "--rock-base-install-dir #{options[:rock_base_install_dir]}"
        arguments += " "
    end
    if options[:patch_dir]
        arguments += "--patch-dir #{options[:patch_dir]}"
        arguments += " "
    end
    if options[:package_version]
        arguments +=  "--package-version '#{options[:package_version]}'"
        arguments += " "
    end
    distribution = packager.target_platform.distribution_release_name
    architecture = packager.target_platform.architecture

    arguments += "--distributions #{distribution}"
    arguments += " "
    arguments += "--architectures #{architecture}"
    arguments += " "
    if options[:meta_depends]
        arguments += "--meta #{pkg_name}"
        arguments += " "
        arguments += options[:meta_depends].join(" ")
    else
        arguments +="#{pkg_name}"
    end

    # Create logging directory
    log_dir = File.join(packager.log_dir,"#{distribution}-#{architecture}")
    if !File.directory?(log_dir)
        FileUtils.mkdir_p log_dir
    end

    puts "Debian packaging: '#{pkg_name}' with arguments #{arguments}"
    if options[:rebuild] || !packager.reprepro_has_package?(options[:debian_package_name], options[:release_name], distribution, architecture)
        puts "############### package #{pkg_name} ###################"
        rebuild_log = File.join(log_dir, "#{options[:debian_package_name]}-deb_local-rebuild.log")
        cmd = "deb_package --package --rebuild #{arguments} > #{rebuild_log}"
        puts "Execution of: #{cmd}"
        if !system(cmd)
            raise RuntimeError, "Local rebuild of pkg #{pkg_name} failed -- see #{rebuild_log}"
        end
        puts "############### build #{pkg_name} #####################"
        debian_package_dir = packager.packaging_dir(options[:debian_package_name])
        dsc_file = Dir.glob(File.join(debian_package_dir,"*.dsc")).first
        options[:log_file] ||= File.join(log_dir, "#{options[:debian_package_name]}-deb_local-build.log")
        puts "Building package from #{dsc_file} -- see log (#{options[:log_file]})"

        options[:result_dir] ||= debian_package_dir
        Autoproj::Packaging::Installer.build_package_from_dsc(dsc_file,
                                         distribution,
                                         architecture,
                                         options[:release_name],
                                         options)

        deb_file = Dir.glob(File.join(debian_package_dir,"*.deb"))
        if deb_file.empty?
            raise RuntimeError, "Building package failed"
        end
        deb_file = deb_file.first
        puts "Registering debian package: #{deb_file}"
        packager.register_debian_package(deb_file,
                                        options[:release_name],
                                        distribution)
    end

    if options[:install]
        if Autoproj::Packaging::Installer.installed?(options[:debian_package_name])
            puts "Package: #{options[:debian_package_name]} is already installed"
        end

        if packager.target_platform == Autoproj::Packaging::TargetPlatform.autodetect_target_platform
            puts "############### install #{pkg_name} #####################"
            install_log = File.join(log_dir,"#{options[:debian_package_name]}-deb_local-install.log")
            cmd = "deb_package --install #{arguments} > #{install_log}"
            puts "Execution of: #{cmd}"
            if !system(cmd)
                raise RuntimeError, "Local install of pkg #{pkg_name} failed -- see #{install_log}"
            end
        else
            puts "Package has been build for #{packager.target_platform}. Not installing package since current platform is #{Autoproj::Packaging::TargetPlatform.autodetect_target_platform}"
        end
    end
end

o_skip = false
o_verbose = false
o_no_deps = false
o_prepare_local_build = false
o_custom_meta = nil
o_meta_only = false
o_build_meta = false
o_patch_dir = "#{ENV['AUTOPROJ_CURRENT_ROOT']}/deb_patches"
o_distribution = nil
o_architecture = nil
o_dry_run = false
o_register = false
o_deregister = false

build_options = Hash.new
options = OptionParser.new do |opt|
    opt.banner = "Usage: deb_local [options]"
    opt.on('--verbose', 'Display output') do
        o_verbose = true
    end
    opt.on("--patch-dir DIR", String, "Overlay directory to patch existing packages (and created gems) during the packaging process") do |dir|
        patch_dir = File.expand_path(dir)
        if !File.directory?(patch_dir)
            puts "Given patch directory '#{patch_dir}' does not exist"
            exit -1
        end
        o_patch_dir = patch_dir
    end
    opt.on("--release-name NAME", String, "Release name for the generated set of packages -- debian package will be installed in a subfolder with this name in base dir") do |name|
        build_options[:release_name] = name
    end
    opt.on("--rock-base-install-dir DIR", String, "Rock base installation directory (prefix) for deployment of the local debian packages") do |dir|
        require 'pathname'
        if !Pathname.new(dir).absolute?
            raise ArgumentError, "Given path for --rock-base-install-dir has to be absolute, but was relative: '#{dir}'"
        end
        build_options[:rock_base_install_dir] = dir
    end
    opt.on("--rebuild","Rebuild package (otherwise the existing packaged deb will be used") do
        build_options[:rebuild] = true
    end
    opt.on("--no-deps","Ignore building dependencies") do
        o_no_deps = true
    end
    opt.on("--custom-meta NAME", "Build a meta package for all packages on the command line") do |name|
        o_custom_meta = name
    end
    opt.on("--build-meta", "Build meta packages from autoproj meta packages found on the command line") do
        o_build_meta = true
    end
    opt.on("--meta-only", "Build only meta packages(from --custom-meta and --build-meta)") do
        o_meta_only = true
    end
    opt.on("--prepare", "Prepare the local building of packages") do
        o_prepare_local_build = true
    end
    opt.on("--reinstall", "Reinstall already installed packages") do
        build_options[:reinstall] = true
    end
    opt.on("--architecture NAME", "Target architecture to build for") do |arch|
        build_options[:architecture] = arch
    end
    opt.on("--distribution NAME","Target distribution release to build for, e.g. trusty") do |dist|
        build_options[:distribution] = dist
    end
    opt.on("--dry-run", "Show the packages that will be build") do
        o_dry_run = true
    end
    opt.on("--register", "Register a package") do
        o_register = true
    end
    opt.on("--deregister", "Deregister/remove a package") do
        o_deregister = true
    end
end

o_selected_packages = options.parse(ARGV)

build_options[:release_name] ||= 'local'
if File.exists? o_patch_dir
    build_options[:patch_dir] = o_patch_dir
else
    Autoproj.warn "Patch directory: #{patch_dir} does not exist"
    exit 0
end

packager = Autoproj::Packaging::Debian.new(build_options)
if o_prepare_local_build
    puts "Preparing local building of packages"
    Autoproj::Packaging::Installer.install_all_requirements

    tempfile = Tempfile.new("jenkins.conf.")
    document_root = File.join(packager.deb_repository)
    packages_subfolder = build_options[:release_name]
    release_prefix = build_options[:release_name]
    autogenerated_config = tempfile.path

    Autoproj::Packaging::Installer.create_webserver_config(document_root, packages_subfolder,
                                                           release_prefix, autogenerated_config)
    Autoproj::Packaging::Installer.install_webserver_config(autogenerated_config, release_prefix)

    if build_options[:release_name]
        packager.initialize_reprepro_repository(build_options[:release_name])
    end

    puts "Preparation completed"
    exit 0
end

if o_register
    if !build_options[:distribution]
        puts "Please provide the distribution for deregistration"
        exit 0
    end
    if !build_options[:release_name]
        puts "Please provide the release_name for deregistration"
        exit 0
    end
    o_selected_packages.each do |pkg_name_expression|
        packager.register_debian_package("#{pkg_name_expression}",
                                           build_options[:release_name],
                                           build_options[:distribution])
    end
    exit 0
end

if o_deregister
    if !build_options[:distribution]
        puts "Please provide the distribution for deregistration"
        exit 0
    end
    if !build_options[:release_name]
        puts "Please provide the release_name for deregistration"
        exit 0
    end
    o_selected_packages.each do |pkg_name_expression|
        packager.deregister_debian_package("#{pkg_name_expression}",
                                           build_options[:release_name],
                                           build_options[:distribution])
    end
    exit 0
end

Autoproj.silent = true
root_dir  = Autoproj::CmdLine.initialize_root_directory
selection = Autoproj::CmdLine.initialize_and_load(nil)

packager.rock_release_name = build_options[:release_name]
build_options[:packager] = packager
packager.initialize_reprepro_repository(build_options[:release_name])
puts "Building local package for: #{packager.target_platform}"

selected_rock_packages = o_selected_packages.select do |name|
    if pkg = Autoproj.manifest.package(name)
        Autoproj.debug "Package: #{name} is a known rock package"
        true
    elsif Autoproj::Packaging::GemDependencies::is_gem?(name)
        Autoproj.debug "Package: #{name} is a gem"
        packager.ruby_gems << [name, nil]
        false
    else
        true
    end
end

Autoproj.info "Selected_packages: #{o_selected_packages} --> rock_packages: #{selected_rock_packages}, gems: #{packager.ruby_gems}"

# When a ruby gem shall be packaged directly there are no selected rock
# packages, but selected ony
is_gem = selected_rock_packages.empty? && !o_selected_packages.empty?
if !is_gem
    selection = Autoproj::CmdLine.initialize_and_load(selected_rock_packages)
    selection = Autoproj::CmdLine.resolve_user_selection(selection).packages
end

# Compute dependencies for a given selection
packager.package_set_order = ["orocos.toolchain","rock.core","rock"]
all_rock_packages = packager.all_required_packages selection
rock_packages = all_rock_packages[:packages]
required_gems = all_rock_packages[:gems]
required_gems_versions = all_rock_packages[:gem_versions]

# create a custom meta package from the package that are listed on the
# command line including they gem dependencies
meta_packages = {}
if o_custom_meta
    meta_packages[o_custom_meta] = rock_packages.collect {|pkg| pkg.name } +
                            required_gems
end

# check if the current collection in the manifest contains a
# metapackage
if o_build_meta
    o_selected_packages.each do |sel|
        if Autoproj.manifest.metapackages.has_key?(sel)
            meta_packages[sel] = Autoproj.manifest.metapackages[sel].packages.collect { |pkg| pkg.name }
        end
    end
end

# Create logging directory
distribution = packager.target_platform.distribution_release_name
architecture = packager.target_platform.architecture
log_dir = File.join(packager.log_dir,"#{distribution}-#{architecture}")
if !File.directory?(log_dir)
    FileUtils.mkdir_p log_dir
end

succeeded_gem_builds = []
failed_gem_builds = []
status = {}
if !required_gems || required_gems.empty?
    puts "# No Gems to be packaged"
else
    puts "# Packaging Gems ---- #{required_gems}"
    index = 0
    required_gems.each do |pkg|
        begin
            is_osdeps = false
            native_name, is_osdeps = packager.native_dependency_name(pkg)
            if is_osdeps
                Autoproj.debug "Gem: #{pkg} is available as os dependency: #{native_name} (therefore it will not be build)"
                next
            end

            pkg_build_options = build_options.dup
            pkg_build_options[:debian_package_name] = packager.debian_ruby_name(pkg,true)
            if version = required_gems_versions[pkg]
                pkg_build_options[:package_version] = version
            end
            if !o_no_deps || pkg =~ /#{o_selected_packages.first}/
                index += 1
                puts "    (#{index}) #{pkg}"
                if !o_dry_run
                    build_locally(packager, pkg, pkg_build_options)
                end
                succeeded_gem_builds << [index, pkg, version]
            end
        rescue SignalException => e
            puts "Package building aborted by user"
            exit 0
        rescue Exception => e
            puts "    package: #{pkg} building failed"
            puts e.message
            puts e.backtrace.join("\n")
            failed_gem_builds << [index, pkg, version]
        ensure
            status['gems'] = { "succeeded" => succeeded_gem_builds,
                     "failed" => failed_gem_builds }

            File.write(File.join(log_dir,'deb_local-build_results.yml'), status.to_yaml)
        end
    end
end

succeeded_pkg_builds = []
failed_pkg_builds = []
if !rock_packages || rock_packages.empty?
    puts "# No Rock Packages to be packaged"
elsif o_meta_only
    puts "# Creating only the meta package requested"
else
    pkg_names = rock_packages.collect {|pkg| pkg.name }
    puts "# Packaging Rock Packages --- #{pkg_names}"
    index = 0
    rock_packages.each do |pkg|
        begin
            if Autoproj.manifest.ignored?(pkg.name)
                puts "    package is on the ignore list"
                next
            end
            pkg_build_options = build_options.dup
            pkg_build_options[:debian_package_name] = packager.debian_name(pkg,true)
            if !o_no_deps || pkg.name =~ /#{o_selected_packages.first}/
                index += 1
                puts "    (#{index}) #{pkg.name}"
                if !o_dry_run
                    build_locally(packager, pkg.name, pkg_build_options)
                end
                succeeded_pkg_builds << [index, pkg.name]
            end
        rescue SignalException => e
            puts "Package building aborted by user"
            exit 0
        rescue Exception => e
            puts "    package: #{pkg.name} building failed"
            puts e.message
            puts e.backtrace.join("\n")
            failed_pkg_builds << [index, pkg.name]
        ensure
            status['packages'] = { :succeeded => succeeded_pkg_builds,
                     :failed => failed_pkg_builds }

            File.write(File.join(log_dir,'deb_local-build_results.yml'), status.to_yaml)
        end
    end
end

succeeded_meta_builds = []
failed_meta_builds = []

index = 0
meta_packages.each do |pkg_name,depend_names|
    puts "# Creating meta package #{pkg_name} --- #{depend_names}"

    begin
        pkg_build_options = build_options.dup
        pkg_build_options[:debian_package_name] = packager.debian_meta_name(pkg_name,true)
        pkg_build_options[:meta_depends] = depend_names
        pkg_build_options[:rebuild] = false
        index += 1
        puts "    (#{index}) #{pkg_name}"
        build_locally(packager, pkg_name, pkg_build_options)
    rescue Exception => e
        puts "    package: #{pkg_name} building failed"
        puts e.message
        puts e.backtrace.join("\n")
        failed_meta_builds << [index, pkg_name]
    end
end

puts "Gem building succeeded for: #{succeeded_gem_builds}"
puts "Pkg building succeeded for: #{succeeded_pkg_builds}"
puts "Meta building succeeded for: #{succeeded_meta_builds}"
puts ""
puts "Gem building failed for: #{failed_gem_builds}"
puts "Pkg building failed for: #{failed_pkg_builds}"
puts "Meta building failed for: #{failed_meta_builds}"
